In kubernetes ,a service is an abstraction layer that provides a stable network endpoint (ip+DNS name )to access one or nore pod 

Pods are ephemeral - they can die ,restart ro be replaced but the service stays constant

So  instead of connecting directly to Pods (whose IP'S keep changing ) you connect to a service and it automatically 
routes traffic to the healthy pods behind it.


 Purpose  of a Service

Purpose                                                            Examplanation

Stable Access                                   Provide a fixed IP  and DNS name to reach set of Pods

Load Balancing                                  Distributes traffic  across  multiple Pod replicas

Decoupling                                      Allows forntend and backend components to communicate without knowing 
                                                knowning Pod IP's

Services Discovery                              Other Pods can discovers and connects to it using environment variable 
                                                or DNS

How a service works
*Pods have lables eg: app: myapp
*The services uses a selector to match those lables
*The kube-proxy component on each node watches for service definition and sets up the network rules
*When a request comes to the servier 's IP . It automatically load balanced to one of the mathcing pods

------------------------------------------------------------------------------------------------------------------------
Type of Kubernetes services:

1.clusterIP (default)
  Accessible only within tht cluster
  Used for internal communication betweeen services

apiVersoin: 1
kind: Service
metadata: 
  name: backend
spec: 
  type: ClusterIP
  selector:
    app: backend 
  posts:
    - port: 80
      targetPort: 8080

use case frontend servies call the backend services inside the cluster
------------------------------------------------------------------------------------------------------------------
NodePort:

 Exposes the services on each NOdes IP at a static 
 YOu can access it using (http://<node_ip>:<node_port>

Example 
apiVersion: v1
kind: Services
metadata:
  name: myapp
spec
  type: NodePort
  selector:
    app: myapp
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30007

Use case 
 when you want to expose your app ot the outside world fo testing or externeal access

-----------------------------------------------------------------------------------------------------------------
3.LoadBalancing

*works only on cloud platforms 
*Automatically provisions a cloud load balancers
*The load balancers routes traffic to the nodeport then to the pods

apiVerison: v1
kind: Service
metadata: 
  name: myapp-lb
spec:
  type: loadbalancer
  selector: 
    app: myapp
  ports:
   - port: 80
     targetPort: 8080

usecase Production deployment -exposing the app publicly with managed load balancing

--------------------------------------------------------------------------------------------------------------------

4.External name 
  Maps  a Services inside the cluster to an external DNS name:
  No selector ,no pods - its just a DNS alias

apiVersion: v1
kind:  Services
metadata: 
  name: external-db
spec: 
  type: ExternalName
  externalName: database.example.com

when your application need to access an external service (like external database)
--------------------------------------------------------------------------------------------------------------------
5.Headless Service

*Special case: ClusterIP: None
*NO load balancing or proxy - the DNS returns the IP'S of alll Pods directly

apiVersion: v1
kind: Services
metadata: 
   name: myapp_headless
spec: 
  clusterIP: none
  selector: m
    app: myap
  ports: 
    - port: 80 
      targetPort: 8080

for stateful workload like databases  where each pod must be addressed individually

---------------------------------------------------------------------------------------------------------------------
5.Service discovery 
-------------------

There are two ways other pods can find the services:

1.Environment Variable
Kubernetes  inject services details into Pods automatically
 
MYAPP_SERVICES_HOST=10.0.0.12
MYAPP_SERVICES_PORT=80

2.DNS 
*each service gets a DNS name like 
 myapp,default.svc.cluster.local

pods can use this name directly to communicate

----------------------------------------------------------------------------------------------------------------------
6.LoadBalancing

Kubernetes Services use kube-proxy which support
*Round Robin load balancing (by default)
*Session affinity (optional)
*IPVS or iptable modes for routing

Example session affinity

spec: 
  sessionAffinity: ClientIP


